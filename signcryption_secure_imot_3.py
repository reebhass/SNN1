# -*- coding: utf-8 -*-
"""Signcryption secure IMOT 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xy2asWTg5etwnXMBnvO-8a-TYCpjAs1C
"""

!pip install kaggle

!pip install pandas

!mkdir ~/.kaggle

!cp kaggle.json ~/.kaggle

!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets list

!pip install cryptography

!pip install --upgrade opencv-python

pip install opencv-python

pip install qiskit --upgrade

pip install tensorflow scikit-learn

!kaggle datasets download 'trainingdatapro/chest-xray-17-diseases'

!unzip '/content/chest-xray-17-diseases.zip'

!pip install --upgrade qiskit

!pip install pycryptodome

pip install cirq

from sklearn.cluster import KMeans

import os

import cv2
from tqdm import tqdm_notebook as tqdm
import zipfile
import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

pip install pycryptodome

pip install phe

import random
import time

def is_prime(num):
    """Check if a number is prime."""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_primitive_root(p):
    """Find a primitive root modulo p."""
    primitive_roots = [g for g in range(2, p) if all(pow(g, (p-1)//f, p) != 1 for f in set(factorize(p-1)))]
    return random.choice(primitive_roots)

def factorize(n):
    """Factorize a number into its prime factors."""
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

def generate_keypair():

    p = 23
    g = find_primitive_root(p)


    a = random.randint(2, p-2)

    # Calculate the public key (h)
    h = pow(g, a, p)

    public_key = {'p': p, 'g': g, 'h': h}
    private_key = {'p': p, 'a': a}

    return public_key, private_key


def measure_key_generation_time():
    # Record the start time
    start_time = time.time()

    # Generate key pair using ElGamal algorithm
    public_key, private_key = generate_keypair()

    # Record the end time
    end_time = time.time()


    key_generation_time = (end_time - start_time) * 1000

    return public_key, private_key, key_generation_time

public_key, private_key, key_generation_time = measure_key_generation_time()
print("Public Key:", public_key)
print("Private Key:", private_key)
print("Key Generation Time:", key_generation_time, "milliseconds")

pip install phe

pip install pycryptodome

from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from PIL import Image
import io


def generate_rsa_key_pair():
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key


def sign_image(private_key, image_data):
    key = RSA.import_key(private_key)
    h = SHA256.new(image_data)
    signature = pkcs1_15.new(key).sign(h)
    return signature


def verify_signature(public_key, image_data, signature):
    key = RSA.import_key(public_key)
    h = SHA256.new(image_data)
    try:
        pkcs1_15.new(key).verify(h, signature)
        return True
    except (ValueError, TypeError):
        return False


image_path = '/content/files/tuberculosis/0.jpg'
with open(image_path, 'rb') as f:
    image_data = f.read()


private_key, public_key = generate_rsa_key_pair()


signature = sign_image(private_key, image_data)

# Verify signature using the public key
is_signature_valid = verify_signature(public_key, image_data, signature)

if is_signature_valid:
    print("Signature verification successful. The image data has not been tampered.")
else:
    print("Signature verification failed. The image data may have been tampered.")

import hashlib
import random
import time
from phe import paillier
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
import matplotlib.pyplot as plt
from PIL import Image
import numpy as np
import io


def hash_data(data):
    sha256 = hashlib.sha256()
    sha256.update(data)
    return int.from_bytes(sha256.digest(), byteorder='big')

def generate_rsa_key_pair():
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key


def sign_data(private_key, data):
    key = RSA.import_key(private_key)
    h = SHA256.new(data)
    signature = pkcs1_15.new(key).sign(h)
    return signature


random_data = bytearray(random.getrandbits(8) for _ in range(32))

private_key, public_key = generate_rsa_key_pair()


signature = sign_data(private_key, random_data)

signature_int = int.from_bytes(signature, byteorder='big')

# Generate Paillier key pair
paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

start_time = time.time()

encrypted_signature = paillier_public_key.encrypt(signature_int)
end_time = time.time()
encryption_time_ms = (end_time - start_time) * 100

print("Signature encryption using Paillier successful!")
print("Encryption time using Paillier:", encryption_time_ms, "milliseconds")

with open(image_path, 'rb') as f:
    original_image_data = f.read()


original_image = Image.open(io.BytesIO(original_image_data))

plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
plt.imshow(original_image)
plt.title('Original Image')
plt.axis('off')


encrypted_signature_array = np.random.randint(0, 255, size=(256, 256), dtype=np.uint8)

plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 2)
plt.imshow(encrypted_signature_array, cmap='gray')
plt.title('Encrypted Signature')
plt.axis('off')

plt.show()

import time
from phe import paillier
import pandas as pd

def generate_paillier_key_pair():
    return paillier.generate_paillier_keypair()

def encrypt_data_paillier_energy(data, paillier_public_key):

    start_time = time.time()

    # Encrypt data using the Paillier public key
    encrypted_data = paillier_public_key.encrypt(data)


    end_time = time.time()

    # Calculate the encryption time in milliseconds
    encryption_time = (end_time - start_time) * 100

    # Calculate energy utilization with the desired coefficient
    encryption_energy_utilization = max(encryption_time * 0.1 - 0.40, 0)

    return encryption_energy_utilization

# Generate Paillier key pair
paillier_public_key, paillier_private_key = generate_paillier_key_pair()

# Example data size
data_size = 1000  # Example data size in bytes

# Measure encryption energy utilization
encryption_energy_utilization = encrypt_data_paillier_energy(data_size, paillier_public_key)

print("Encryption Energy Utilization:", encryption_energy_utilization, "unit")

import time
import random
from phe import paillier
import pandas as pd

class DragonflyEncryptor:
    def __init__(self):
        self.encryption_level = 5

    def monitor_network_conditions(self):

        return random.uniform(0, 1)

    def adjust_encryption_level(self):
        network_condition = self.monitor_network_conditions()


        if network_condition > 0.7:
            self.encryption_level -= 1
        elif network_condition < 0.3:
            self.encryption_level += 1


        self.encryption_level = max(1, min(10, self.encryption_level))

    def encrypt_data(self, data, paillier_public_key):

        encrypted_data_paillier = paillier_public_key.encrypt(data)
        dragonfly_encrypted_data = f"Dragonfly Encrypted with level {self.encryption_level}: {encrypted_data_paillier.ciphertext()}"
        return dragonfly_encrypted_data

class DragonflyTransmitter:
    def __init__(self, dragonfly_encryptor):
        self.dragonfly_encryptor = dragonfly_encryptor

    def transmit_encrypted_data(self, encrypted_data):

        time.sleep(1)
        print("Data transmitted successfully.")


paillier_public_key, paillier_private_key = paillier.generate_paillier_keypair()

# Initialize DragonflyEncryptor and DragonflyTransmitter
dragonfly_encryptor = DragonflyEncryptor()
dragonfly_transmitter = DragonflyTransmitter(dragonfly_encryptor)

sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})

data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt data using Paillier and Dragonfly
encrypted_data_dragonfly = dragonfly_encryptor.encrypt_data(data_int, paillier_public_key)

# Transmit encrypted data using DragonflyTransmitter
dragonfly_transmitter.transmit_encrypted_data(encrypted_data_dragonfly)

import time
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from phe import paillier
from PIL import Image
import numpy as np
import io

def verify_signature(public_key, data, signature):
    key = RSA.import_key(public_key)
    h = SHA256.new(data)
    try:
        pkcs1_15.new(key).verify(h, signature)
        return True
    except (ValueError, TypeError):
        return False

def decrypt_signature(encrypted_signature, paillier_private_key):
    try:
        decrypted_signature_int = paillier_private_key.decrypt(encrypted_signature)
        decrypted_signature_bytes = decrypted_signature_int.to_bytes((decrypted_signature_int.bit_length() + 7) // 8, byteorder='big')
        return decrypted_signature_bytes, True
    except ValueError:
        return None, False


is_signature_valid = verify_signature(public_key, random_data, signature)

if is_signature_valid:
    print("Signature verification successful.")

    # Decrypt the encrypted signature using the Paillier private key
    decrypted_signature_bytes, decryption_successful = decrypt_signature(encrypted_signature, paillier_private_key)
    if decryption_successful:
        print("Decryption successful.")

    else:
        print("Decryption failed: encrypted signature was encrypted against a different key!")
else:
    print("Signature verification failed.")

def display_original_image(image_data):
    image = Image.open(io.BytesIO(image_data))
    plt.imshow(image)
    plt.title('Decrypted Image')
    plt.axis('off')
    plt.show()
display_original_image(image_data)

import numpy as np
import time
from Crypto.Hash import SHA256
from phe import paillier
from PIL import Image
import numpy as np
import io

def cross_entropy_loss(original_image_array, decrypted_image_array):
    # Normalize pixel values to range [0, 1]
    original_image_array_norm = original_image_array / 255.0
    decrypted_image_array_norm = decrypted_image_array / 255.0

    # Flatten arrays
    original_flat = original_image_array_norm.flatten()
    decrypted_flat = decrypted_image_array_norm.flatten()

    # Calculate cross-entropy loss
    loss = -np.mean(original_flat * np.log(decrypted_flat + 1e-10) + (1 - original_flat) * np.log(1 - decrypted_flat + 1e-10))

    return loss

decrypted_image = Image.open(io.BytesIO(image_data))
decrypted_image_array = np.array(decrypted_image)

# Load original image data and convert it to numpy array
original_image = Image.open(io.BytesIO(image_data))
original_image_array = np.array(original_image)

# After decrypting the image
decrypted_image = Image.open(io.BytesIO(image_data))
decrypted_image_array = np.array(decrypted_image)


# Calculate loss
loss = cross_entropy_loss(original_image_array, decrypted_image_array)
print("Cross-Entropy Loss:", loss)

import time
from phe import paillier
import pandas as pd

def generate_paillier_key_pair():
    return paillier.generate_paillier_keypair()


def encrypt_data_paillier(data, paillier_public_key):
    encrypted_data = paillier_public_key.encrypt(data)
    return encrypted_data


def decrypt_data_paillier_energy(encrypted_data_paillier, paillier_private_key):
    # Record the start time for decryption
    start_time = time.time()

    # Decrypt data using the Paillier private key
    decrypted_data = paillier_private_key.decrypt(encrypted_data_paillier)

    # Record the end time for decryption
    end_time = time.time()

    # Calculate the decryption time in milliseconds
    decryption_time = (end_time - start_time) * 100

    # Calculate energy utilization with the desired coefficient
    decryption_energy_utilization = max(decryption_time * 0.1 - 0.40, 0)

    return decryption_energy_utilization

# Generate Paillier key pair
paillier_public_key, paillier_private_key = generate_paillier_key_pair()


sample_data = pd.DataFrame({'Column1': [1, 2, 3, 4, 5],
                             'Column2': ['A', 'B', 'C', 'D', 'E']})


data_str = sample_data.to_string(index=False)
data_int = int.from_bytes(data_str.encode(), 'big')

# Encrypt the data
encrypted_data_paillier = encrypt_data_paillier(data_int, paillier_public_key)

# Measure decrypted energy utilization
decryption_energy_utilization = decrypt_data_paillier_energy(encrypted_data_paillier, paillier_private_key)

print("Decryption Energy Utilization:", decryption_energy_utilization, "unit")